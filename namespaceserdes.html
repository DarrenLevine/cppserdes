<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>CppSerdes: serdes Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="cppserdes_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CppSerdes
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">A serialization/deserialization library designed with embedded systems in mind</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceserdes.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">serdes Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>CppSerdes library namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceserdes_1_1init__formatter"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceserdes_1_1init__formatter.html">init_formatter</a></td></tr>
<tr class="memdesc:namespaceserdes_1_1init__formatter"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="serdes__formatter_8h.html#a5caecdacd13d020a010de97b5d079f6f" title="init_formatter() constructs a serdes::formatter object lambda without using dynamic memory allocation...">init_formatter()</a> constructs a <a class="el" href="structserdes_1_1formatter.html" title="a lambda function wrapper that can describe any serialization/deserialization formatting process...">serdes::formatter</a> object lambda without using dynamic memory allocation. A number of different use cases are supported, see <a class="el" href="structserdes_1_1formatter.html" title="a lambda function wrapper that can describe any serialization/deserialization formatting process...">serdes::formatter</a> for examples. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceserdes_1_1init__this__formatter"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceserdes_1_1init__this__formatter.html">init_this_formatter</a></td></tr>
<tr class="memdesc:namespaceserdes_1_1init__this__formatter"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="serdes__formatter_8h.html#acbe8baef2627a7cb1e6cf602a1164634" title="init_this_formatter() constructs a serdes::formatter object lambda without using dynamic memory alloc...">init_this_formatter()</a> constructs a <a class="el" href="structserdes_1_1formatter.html" title="a lambda function wrapper that can describe any serialization/deserialization formatting process...">serdes::formatter</a> object lambda without using dynamic memory allocation. Same as <a class="el" href="namespaceserdes_1_1init__formatter.html" title="init_formatter() constructs a serdes::formatter object lambda without using dynamic memory allocation...">init_formatter</a> but captures "this", only necessary for older compilers which don't capture "this" automatically. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceserdes_1_1literals"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceserdes_1_1literals.html">literals</a></td></tr>
<tr class="memdesc:namespaceserdes_1_1literals"><td class="mdescLeft">&#160;</td><td class="mdescRight">provides fixed size literals, useful when specifying serialization actions to convey exact bit widths <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserdes_1_1align.html">align</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specifies a number of bits to be used to align the bit offset as a multiple of  <a href="structserdes_1_1align.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserdes_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a container for fixed or dynamically sized arrays, with an upper bounds limit for safety  <a href="structserdes_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserdes_1_1bitpack.html">bitpack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">bitpack a value into an exact number of specified bits. If applied to an array it will be applied to each element of the array, not the total bits in the array  <a href="structserdes_1_1bitpack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserdes_1_1delimited__array.html">delimited_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a container for dynamically sized arrays with their ending marked by a reserved delimiter value  <a href="structserdes_1_1delimited__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserdes_1_1formatter.html">formatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a lambda function wrapper that can describe any serialization/deserialization formatting process. While it does use more overhead (because of the lambda), it also can describe any format process as manipulatable runtime data, which the other hard coded interfaces don't allow.<br />
 <a href="structserdes_1_1formatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserdes_1_1info.html">info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CppSerdes library information.  <a href="structserdes_1_1info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserdes_1_1packet.html">packet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a serialization/deserialization helper class, with load, store, and stream operators  <a href="structserdes_1_1packet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserdes_1_1packet__base.html">packet_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">inheritable base class to allow format recording and application with no additional memory storage (except for the virtual table pointer)  <a href="structserdes_1_1packet__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserdes_1_1pad.html">pad</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specifies a number of bits to be used to pad (add to) the current bit offset  <a href="structserdes_1_1pad.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a pointer to an array (with its type information) with a constant size.  <a href="structserdes_1_1sized__pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserdes_1_1sized__pointer_3_01void_01_4.html">sized_pointer&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a pointer to a void array (with type information stored as a runtime element size paramenter) with a constant size.  <a href="structserdes_1_1sized__pointer_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structserdes_1_1status__t.html">status_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">status returned after any serialization/deserialization process  <a href="structserdes_1_1status__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1386add7959df5d7268423869485cd3e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#a1386add7959df5d7268423869485cd3e">status_e</a> { <br />
&#160;&#160;<a class="el" href="namespaceserdes.html#a1386add7959df5d7268423869485cd3ead306b6fdee05fe87455110ddf6501e6c">status_e::NO_ERROR</a> = 0, 
<a class="el" href="namespaceserdes.html#a1386add7959df5d7268423869485cd3ead42fa0a6c17a7f1ad5054b3f0466442e">status_e::EXCEEDED_SERIAL_SIZE</a> = 1, 
<a class="el" href="namespaceserdes.html#a1386add7959df5d7268423869485cd3ea0a1fc9858ab81a7864ed427c590b3457">status_e::ARRAY_SIZE_OVER_MAX</a> = 2, 
<a class="el" href="namespaceserdes.html#a1386add7959df5d7268423869485cd3eab0b3809be1740d3f1c8d5f4c225ed774">status_e::INVALID_FIELD</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespaceserdes.html#a1386add7959df5d7268423869485cd3eacce998e2340482b1544fb0e9ddd65d02">status_e::NO_LOAD_TO_RVALUE</a> = 4, 
<a class="el" href="namespaceserdes.html#a1386add7959df5d7268423869485cd3ea094d2eb6e3f6b6a7862b400026526a7e">status_e::DELIMITER_NOT_FOUND</a> = 5, 
<a class="el" href="namespaceserdes.html#a1386add7959df5d7268423869485cd3ea2d9d52b93e3296d1a982d0ac57a1a9b6">status_e::FORMATTER_NOT_SET</a> = 6
<br />
 }<tr class="memdesc:a1386add7959df5d7268423869485cd3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">error status of serialization/deserialization process  <a href="namespaceserdes.html#a1386add7959df5d7268423869485cd3e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a1386add7959df5d7268423869485cd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a421ec15756a7c68f366e643f706b41c5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#a421ec15756a7c68f366e643f706b41c5">mode_e</a> { <a class="el" href="namespaceserdes.html#a421ec15756a7c68f366e643f706b41c5af9f6955ebca09a484157c05f80acd65e">mode_e::LOADING</a>, 
<a class="el" href="namespaceserdes.html#a421ec15756a7c68f366e643f706b41c5a9ef20aabc0be8b632e8190984133a6cb">mode_e::STORING</a>, 
<a class="el" href="namespaceserdes.html#a421ec15756a7c68f366e643f706b41c5a1c04cc3823d476c3017238679a0fdf52">mode_e::UNSPECIFIED</a>
 }<tr class="memdesc:a421ec15756a7c68f366e643f706b41c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">the serdes mode of operation  <a href="namespaceserdes.html#a421ec15756a7c68f366e643f706b41c5">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a421ec15756a7c68f366e643f706b41c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aae83c837de13826a8e931d10eb863da6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae83c837de13826a8e931d10eb863da6"><td class="memTemplItemLeft" align="right" valign="top">constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#aae83c837de13826a8e931d10eb863da6">bit_length</a> (T &amp;&amp;x) noexcept</td></tr>
<tr class="memdesc:aae83c837de13826a8e931d10eb863da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does nothing but annotate a passed value as a bit length, used for writting clearer code.  <a href="#aae83c837de13826a8e931d10eb863da6">More...</a><br /></td></tr>
<tr class="separator:aae83c837de13826a8e931d10eb863da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb36906db6ba496a47d522c5ccbdb85e"><td class="memTemplParams" colspan="2">template&lt;typename T_array , typename T_val , detail::requires_unsigned_type&lt; T_val &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeb36906db6ba496a47d522c5ccbdb85e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#aeb36906db6ba496a47d522c5ccbdb85e">bitcpy</a> (T_val &amp;dest, const T_array *const source, const size_t bit_offset=0, const size_t bits=detail::default_bitsize&lt; T_val &gt;::value) noexcept</td></tr>
<tr class="memdesc:aeb36906db6ba496a47d522c5ccbdb85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">[[deserialize, uint destination]] copies the specified number of bits from an array into a value  <a href="#aeb36906db6ba496a47d522c5ccbdb85e">More...</a><br /></td></tr>
<tr class="separator:aeb36906db6ba496a47d522c5ccbdb85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac420621710d6586ff55c2f760e6b0bd0"><td class="memTemplParams" colspan="2">template&lt;typename T_array , typename T_val , detail::requires_small_non_integral_type&lt; T_val &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac420621710d6586ff55c2f760e6b0bd0"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#ac420621710d6586ff55c2f760e6b0bd0">bitcpy</a> (T_val &amp;dest, const T_array *const source, const size_t bit_offset=0, const size_t bits=detail::default_bitsize&lt; T_val &gt;::value) noexcept</td></tr>
<tr class="memdesc:ac420621710d6586ff55c2f760e6b0bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">[[deserialize, integral value &lt;= 8 bytes destination]] copies the specified number of bits from an array into a integral value with &lt;= 8 bytes  <a href="#ac420621710d6586ff55c2f760e6b0bd0">More...</a><br /></td></tr>
<tr class="separator:ac420621710d6586ff55c2f760e6b0bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ab8ae5d7fb01f72921d88143ad838e"><td class="memTemplParams" colspan="2">template&lt;typename T_array , typename T_val , detail::requires_unsigned_type&lt; T_val &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a70ab8ae5d7fb01f72921d88143ad838e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#a70ab8ae5d7fb01f72921d88143ad838e">bitcpy</a> (<a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a>&lt; T_val &gt; &amp;dest, const T_array *const source, const size_t bit_offset, const size_t bits) noexcept</td></tr>
<tr class="memdesc:a70ab8ae5d7fb01f72921d88143ad838e"><td class="mdescLeft">&#160;</td><td class="mdescRight">[[deserialize, partial <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> destination]] copies the specified number of bits from an array into a <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> array (no default bits, since it can't necessarily be known at compile time)  <a href="#a70ab8ae5d7fb01f72921d88143ad838e">More...</a><br /></td></tr>
<tr class="separator:a70ab8ae5d7fb01f72921d88143ad838e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262780a7330bf9baf1e44ba061061210"><td class="memTemplParams" colspan="2">template&lt;typename T_array , typename T_val , detail::requires_unsigned_type&lt; T_val &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a262780a7330bf9baf1e44ba061061210"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#a262780a7330bf9baf1e44ba061061210">bitcpy</a> (<a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a>&lt; T_val &gt; &amp;dest, const T_array *const source, const size_t bit_offset=0) noexcept</td></tr>
<tr class="memdesc:a262780a7330bf9baf1e44ba061061210"><td class="mdescLeft">&#160;</td><td class="mdescRight">[[deserialize, entire <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> destination]] copies the specified number of bits from an array into a <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> array using a bit length equal to the entire bit capacity of the <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> object.  <a href="#a262780a7330bf9baf1e44ba061061210">More...</a><br /></td></tr>
<tr class="separator:a262780a7330bf9baf1e44ba061061210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6f27bcacd3783064c59334545bccbc"><td class="memTemplParams" colspan="2">template&lt;typename T_array  = void, typename T_val  = void, detail::requires_not_a_pointer_type&lt; T_val &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1e6f27bcacd3783064c59334545bccbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#a1e6f27bcacd3783064c59334545bccbc">bitcpy</a> (T_val &amp;dest, const <a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a>&lt; T_array &gt; source, size_t bit_offset=0, const size_t bits=detail::default_bitsize&lt; T_val &gt;::value) noexcept</td></tr>
<tr class="memdesc:a1e6f27bcacd3783064c59334545bccbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">[[deserialize, size safe]] copies the specified number of bits from an <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> into a value. used to prevent reading beyond the boundary of the source array.  <a href="#a1e6f27bcacd3783064c59334545bccbc">More...</a><br /></td></tr>
<tr class="separator:a1e6f27bcacd3783064c59334545bccbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4d398974f1f43688103da879266b5d"><td class="memTemplParams" colspan="2">template&lt;typename T_array  = void, typename T_val  = void, detail::requires_pointer_type&lt; T_val &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aae4d398974f1f43688103da879266b5d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#aae4d398974f1f43688103da879266b5d">bitcpy</a> (T_val &amp;dest, const <a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a>&lt; T_array &gt; source, const size_t bit_offset=0, const size_t bits=detail::default_bitsize&lt; T_val &gt;::value) noexcept</td></tr>
<tr class="memdesc:aae4d398974f1f43688103da879266b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">[[deserialize, size safe, pointer dest]] copies the specified number of bits from an <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> into a value. used to prevent reading beyond the boundary of the source array.  <a href="#aae4d398974f1f43688103da879266b5d">More...</a><br /></td></tr>
<tr class="separator:aae4d398974f1f43688103da879266b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f811a7c84f33ffe68bab7f660e036bb"><td class="memTemplParams" colspan="2">template&lt;typename T_array , typename T_val &gt; </td></tr>
<tr class="memitem:a0f811a7c84f33ffe68bab7f660e036bb"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#a0f811a7c84f33ffe68bab7f660e036bb">bitcpy</a> (std::atomic&lt; T_val &gt; &amp;dest, const T_array *const source, const size_t bit_offset=0, const size_t bits=detail::default_bitsize&lt; T_val &gt;::value) noexcept</td></tr>
<tr class="memdesc:a0f811a7c84f33ffe68bab7f660e036bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">[[deserialize, atomic dest]] copies the specified number of bits from an array into an atomic value  <a href="#a0f811a7c84f33ffe68bab7f660e036bb">More...</a><br /></td></tr>
<tr class="separator:a0f811a7c84f33ffe68bab7f660e036bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a3fc6527a4e0d32080cd8fc33c9492"><td class="memTemplParams" colspan="2">template&lt;typename T_val  = void&gt; </td></tr>
<tr class="memitem:a59a3fc6527a4e0d32080cd8fc33c9492"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#a59a3fc6527a4e0d32080cd8fc33c9492">bitcpy</a> (T_val &amp;dest, const <a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a>&lt; void &gt; &amp;source, const size_t bit_offset=0, const size_t bits=detail::default_bitsize&lt; T_val &gt;::value) noexcept</td></tr>
<tr class="memdesc:a59a3fc6527a4e0d32080cd8fc33c9492"><td class="mdescLeft">&#160;</td><td class="mdescRight">[[deserialize, size safe, type punned (void) source array]] copies the specified number of bits from an array with a runtime determined base type into a value  <a href="#a59a3fc6527a4e0d32080cd8fc33c9492">More...</a><br /></td></tr>
<tr class="separator:a59a3fc6527a4e0d32080cd8fc33c9492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfcaa320138ca1dd74956eaaf2a3855b"><td class="memTemplParams" colspan="2">template&lt;typename T_array , typename T_val , detail::requires_unsigned_type&lt; T_val &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abfcaa320138ca1dd74956eaaf2a3855b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#abfcaa320138ca1dd74956eaaf2a3855b">bitcpy</a> (T_array *const dest, const T_val source, const size_t bit_offset=0, const size_t bits=detail::default_bitsize&lt; T_val &gt;::value) noexcept</td></tr>
<tr class="memdesc:abfcaa320138ca1dd74956eaaf2a3855b"><td class="mdescLeft">&#160;</td><td class="mdescRight">[[serialize, uint source]] copies the specified number of bits from a value into an array  <a href="#abfcaa320138ca1dd74956eaaf2a3855b">More...</a><br /></td></tr>
<tr class="separator:abfcaa320138ca1dd74956eaaf2a3855b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290f80d3a7efd5dda1ba082ca046585f"><td class="memTemplParams" colspan="2">template&lt;typename T_array , typename T_val , detail::requires_unsigned_type&lt; T_val &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a290f80d3a7efd5dda1ba082ca046585f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#a290f80d3a7efd5dda1ba082ca046585f">bitcpy</a> (T_array *const dest, const <a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a>&lt; const T_val &gt; &amp;source, const size_t bit_offset, const size_t bits) noexcept</td></tr>
<tr class="memdesc:a290f80d3a7efd5dda1ba082ca046585f"><td class="mdescLeft">&#160;</td><td class="mdescRight">[[serialize, partial <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> source]] copies the specified number of bits from a value into an array (no default bits, since it can't necessarily be known at compile time)  <a href="#a290f80d3a7efd5dda1ba082ca046585f">More...</a><br /></td></tr>
<tr class="separator:a290f80d3a7efd5dda1ba082ca046585f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3822dc8bf6c6b646b4f919b985be98f"><td class="memTemplParams" colspan="2">template&lt;typename T_array , typename T_val , detail::requires_unsigned_type&lt; T_val &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac3822dc8bf6c6b646b4f919b985be98f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#ac3822dc8bf6c6b646b4f919b985be98f">bitcpy</a> (T_array *const dest, const <a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a>&lt; const T_val &gt; &amp;source, const size_t bit_offset=0) noexcept</td></tr>
<tr class="memdesc:ac3822dc8bf6c6b646b4f919b985be98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">[[serialize, entire <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> source]] copies the entire <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> object from a value into an array  <a href="#ac3822dc8bf6c6b646b4f919b985be98f">More...</a><br /></td></tr>
<tr class="separator:ac3822dc8bf6c6b646b4f919b985be98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed7367b5b4757ec2d64cf63b38e8a92"><td class="memTemplParams" colspan="2">template&lt;typename T_array , typename T_val , detail::requires_large_non_integral_type&lt; T_val &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abed7367b5b4757ec2d64cf63b38e8a92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="bitcpy__common_8h.html#acd60295e3ef245aee68c06dcdb623899">CONSTEXPR_ABOVE_CPP11_AND_NON_LITERAL_STORAGE</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#abed7367b5b4757ec2d64cf63b38e8a92">bitcpy</a> (T_array *const dest, const T_val &amp;source, const size_t bit_offset=0, const size_t bits=detail::default_bitsize&lt; T_val &gt;::value) noexcept</td></tr>
<tr class="memdesc:abed7367b5b4757ec2d64cf63b38e8a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">[[serialize, large non integral type source]] copies the specified number of bits from a value into an array  <a href="#abed7367b5b4757ec2d64cf63b38e8a92">More...</a><br /></td></tr>
<tr class="separator:abed7367b5b4757ec2d64cf63b38e8a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c4caa1535f33f05f3a6d94ba3efcc4"><td class="memTemplParams" colspan="2">template&lt;typename T_array  = void, typename T_val  = void&gt; </td></tr>
<tr class="memitem:aa5c4caa1535f33f05f3a6d94ba3efcc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#aa5c4caa1535f33f05f3a6d94ba3efcc4">bitcpy</a> (<a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a>&lt; T_array &gt; dest, const T_val &amp;source, const size_t bit_offset=0, const size_t bits=detail::default_bitsize&lt; T_val &gt;::value) noexcept</td></tr>
<tr class="memdesc:aa5c4caa1535f33f05f3a6d94ba3efcc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">[[serialize, size safe]] copies the specified number of bits from a value into an sized array  <a href="#aa5c4caa1535f33f05f3a6d94ba3efcc4">More...</a><br /></td></tr>
<tr class="separator:aa5c4caa1535f33f05f3a6d94ba3efcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563cbbec75f2b1acbf054dddfbccfae9"><td class="memTemplParams" colspan="2">template&lt;typename T_array , typename T_val &gt; </td></tr>
<tr class="memitem:a563cbbec75f2b1acbf054dddfbccfae9"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#a563cbbec75f2b1acbf054dddfbccfae9">bitcpy</a> (T_array *const dest, const std::atomic&lt; T_val &gt; &amp;source, const size_t bit_offset=0, const size_t bits=detail::default_bitsize&lt; T_val &gt;::value) noexcept</td></tr>
<tr class="memdesc:a563cbbec75f2b1acbf054dddfbccfae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">[[serialize, atomic source]] copies the specified number of bits from an atomic value into an sized array  <a href="#a563cbbec75f2b1acbf054dddfbccfae9">More...</a><br /></td></tr>
<tr class="separator:a563cbbec75f2b1acbf054dddfbccfae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812ea9df5d30f7477a5fa7f2590cb855"><td class="memTemplParams" colspan="2">template&lt;typename T_val &gt; </td></tr>
<tr class="memitem:a812ea9df5d30f7477a5fa7f2590cb855"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#a812ea9df5d30f7477a5fa7f2590cb855">bitcpy</a> (<a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a>&lt; void &gt; &amp;dest, const T_val &amp;source, const size_t bit_offset=0, const size_t bits=detail::default_bitsize&lt; T_val &gt;::value) noexcept</td></tr>
<tr class="memdesc:a812ea9df5d30f7477a5fa7f2590cb855"><td class="mdescLeft">&#160;</td><td class="mdescRight">[[serialize, size safe, type punned (void) dest array]] copies the specified number of bits from a value into an sized array  <a href="#a812ea9df5d30f7477a5fa7f2590cb855">More...</a><br /></td></tr>
<tr class="separator:a812ea9df5d30f7477a5fa7f2590cb855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51272e70dce3f7117d7d4fcac70ecc4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#a51272e70dce3f7117d7d4fcac70ecc4a">printhex</a> (const uint8_t data, const bool add_newline=true)</td></tr>
<tr class="memdesc:a51272e70dce3f7117d7d4fcac70ecc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints uint8_t value in hex format  <a href="#a51272e70dce3f7117d7d4fcac70ecc4a">More...</a><br /></td></tr>
<tr class="separator:a51272e70dce3f7117d7d4fcac70ecc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99828104ac858f4a260c2f90bc4ad20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#ad99828104ac858f4a260c2f90bc4ad20">printhex</a> (const uint16_t data, const bool add_newline=true)</td></tr>
<tr class="memdesc:ad99828104ac858f4a260c2f90bc4ad20"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints uint16_t value in hex format  <a href="#ad99828104ac858f4a260c2f90bc4ad20">More...</a><br /></td></tr>
<tr class="separator:ad99828104ac858f4a260c2f90bc4ad20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c848bf29b2209e63ee38dad08ad5523"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#a8c848bf29b2209e63ee38dad08ad5523">printhex</a> (const uint32_t data, const bool add_newline=true)</td></tr>
<tr class="memdesc:a8c848bf29b2209e63ee38dad08ad5523"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints uint32_t value in hex format  <a href="#a8c848bf29b2209e63ee38dad08ad5523">More...</a><br /></td></tr>
<tr class="separator:a8c848bf29b2209e63ee38dad08ad5523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab1afab999d6c5890f76ea47095b514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#adab1afab999d6c5890f76ea47095b514">printhex</a> (const uint64_t data, const bool add_newline=true)</td></tr>
<tr class="memdesc:adab1afab999d6c5890f76ea47095b514"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints uint64_t value in hex format  <a href="#adab1afab999d6c5890f76ea47095b514">More...</a><br /></td></tr>
<tr class="separator:adab1afab999d6c5890f76ea47095b514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace267eee6dd224c9a2c1fde6a0f66e32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#ace267eee6dd224c9a2c1fde6a0f66e32">printhex</a> (const bool data, const bool add_newline=true)</td></tr>
<tr class="memdesc:ace267eee6dd224c9a2c1fde6a0f66e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints bool value in hex format  <a href="#ace267eee6dd224c9a2c1fde6a0f66e32">More...</a><br /></td></tr>
<tr class="separator:ace267eee6dd224c9a2c1fde6a0f66e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56375888a9a3ba6d6488a73d6866b75"><td class="memTemplParams" colspan="2">template&lt;typename T  = void, typename std::enable_if&lt; std::is_signed&lt; T &gt;::valueBITCPY_INT128_CONDITIONAL_DEFINE(||std::is_same&lt; T, __int128_t &gt;::value), T &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af56375888a9a3ba6d6488a73d6866b75"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#af56375888a9a3ba6d6488a73d6866b75">printhex</a> (const T data, const bool add_newline=true)</td></tr>
<tr class="memdesc:af56375888a9a3ba6d6488a73d6866b75"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints signed value in hex format  <a href="#af56375888a9a3ba6d6488a73d6866b75">More...</a><br /></td></tr>
<tr class="separator:af56375888a9a3ba6d6488a73d6866b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9208ad46c43f085998183fb3afde4c00"><td class="memTemplParams" colspan="2">template&lt;bool use_brackets = true, typename T  = void, size_t N = 0u&gt; </td></tr>
<tr class="memitem:a9208ad46c43f085998183fb3afde4c00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#a9208ad46c43f085998183fb3afde4c00">printhex</a> (const T(&amp;data)[N], const bool add_newline=true)</td></tr>
<tr class="memdesc:a9208ad46c43f085998183fb3afde4c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints an array in hex format  <a href="#a9208ad46c43f085998183fb3afde4c00">More...</a><br /></td></tr>
<tr class="separator:a9208ad46c43f085998183fb3afde4c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5a3aa91ba45e310943c6704282b9f8"><td class="memTemplParams" colspan="2">template&lt;bool use_brackets = true, typename T  = void, size_t N = 0u&gt; </td></tr>
<tr class="memitem:a8c5a3aa91ba45e310943c6704282b9f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#a8c5a3aa91ba45e310943c6704282b9f8">printbin</a> (const T(&amp;data)[N], const bool add_newline=true)</td></tr>
<tr class="memdesc:a8c5a3aa91ba45e310943c6704282b9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints an array in binary format  <a href="#a8c5a3aa91ba45e310943c6704282b9f8">More...</a><br /></td></tr>
<tr class="separator:a8c5a3aa91ba45e310943c6704282b9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966991bf9e4d6f119b26dd034723033c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt;!std::is_array&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value, T &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a966991bf9e4d6f119b26dd034723033c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#a966991bf9e4d6f119b26dd034723033c">printbin</a> (const T data, const bool add_newline=true)</td></tr>
<tr class="memdesc:a966991bf9e4d6f119b26dd034723033c"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints a non-array non-bool value in binary format  <a href="#a966991bf9e4d6f119b26dd034723033c">More...</a><br /></td></tr>
<tr class="separator:a966991bf9e4d6f119b26dd034723033c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a594b0b4cc5b5a2465fff972f97f064"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#a9a594b0b4cc5b5a2465fff972f97f064">printbin</a> (const bool data, const bool add_newline=true)</td></tr>
<tr class="memdesc:a9a594b0b4cc5b5a2465fff972f97f064"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints a bool value in binary format  <a href="#a9a594b0b4cc5b5a2465fff972f97f064">More...</a><br /></td></tr>
<tr class="separator:a9a594b0b4cc5b5a2465fff972f97f064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb584d0e8c2555c37f71f48e362cc268"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#abb584d0e8c2555c37f71f48e362cc268">status2str</a> (<a class="el" href="namespaceserdes.html#a1386add7959df5d7268423869485cd3e">status_e</a> err_status) noexcept</td></tr>
<tr class="memdesc:abb584d0e8c2555c37f71f48e362cc268"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts an error status enum to a c style string  <a href="#abb584d0e8c2555c37f71f48e362cc268">More...</a><br /></td></tr>
<tr class="separator:abb584d0e8c2555c37f71f48e362cc268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2e5a1c666319dd6cffbf669b1a1acc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d2e5a1c666319dd6cffbf669b1a1acc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#a1d2e5a1c666319dd6cffbf669b1a1acc">virtual_formatter</a> (<a class="el" href="structserdes_1_1packet.html">packet</a> &amp;)</td></tr>
<tr class="memdesc:a1d2e5a1c666319dd6cffbf669b1a1acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to initialize a formatter object to be optionally overridable. the default behaviour if not overridden is to do nothing. <br /></td></tr>
<tr class="separator:a1d2e5a1c666319dd6cffbf669b1a1acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a924639a90e6c11dee4b6ccff5e7660ce"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a924639a90e6c11dee4b6ccff5e7660ce"></a>
constexpr void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceserdes.html#a924639a90e6c11dee4b6ccff5e7660ce">pure_virtual_formatter</a> )(<a class="el" href="structserdes_1_1packet.html">packet</a> &amp;) = nullptr</td></tr>
<tr class="memdesc:a924639a90e6c11dee4b6ccff5e7660ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to initialize a formatter object to be required but uninitialized. the default behaviour if not overridden is to give a <a class="el" href="namespaceserdes.html#a1386add7959df5d7268423869485cd3ea2d9d52b93e3296d1a982d0ac57a1a9b6" title="a pure_virtual_formatter (a.k.a &quot;serdes::formatter(nullptr)&quot;) was used but not overriden (causes the ...">status_e::FORMATTER_NOT_SET</a> error <br /></td></tr>
<tr class="separator:a924639a90e6c11dee4b6ccff5e7660ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>CppSerdes library namespace. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a421ec15756a7c68f366e643f706b41c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceserdes.html#a421ec15756a7c68f366e643f706b41c5">serdes::mode_e</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the serdes mode of operation </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a421ec15756a7c68f366e643f706b41c5af9f6955ebca09a484157c05f80acd65e"></a>LOADING&#160;</td><td class="fielddoc">
<p>(deserializing) loading from serial data into variables </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a421ec15756a7c68f366e643f706b41c5a9ef20aabc0be8b632e8190984133a6cb"></a>STORING&#160;</td><td class="fielddoc">
<p>(serializing) storing variables into serial data </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a421ec15756a7c68f366e643f706b41c5a1c04cc3823d476c3017238679a0fdf52"></a>UNSPECIFIED&#160;</td><td class="fielddoc">
<p>not yet configured for storing/loading </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a1386add7959df5d7268423869485cd3e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceserdes.html#a1386add7959df5d7268423869485cd3e">serdes::status_e</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>error status of serialization/deserialization process </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a1386add7959df5d7268423869485cd3ead306b6fdee05fe87455110ddf6501e6c"></a>NO_ERROR&#160;</td><td class="fielddoc">
<p>no serialization/deserialization errors occurred </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1386add7959df5d7268423869485cd3ead42fa0a6c17a7f1ad5054b3f0466442e"></a>EXCEEDED_SERIAL_SIZE&#160;</td><td class="fielddoc">
<p>during serialization/deserialization the serial array boundary was reached (causes the serdes process to abort) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1386add7959df5d7268423869485cd3ea0a1fc9858ab81a7864ed427c590b3457"></a>ARRAY_SIZE_OVER_MAX&#160;</td><td class="fielddoc">
<p>the <a class="el" href="structserdes_1_1array.html" title="a container for fixed or dynamically sized arrays, with an upper bounds limit for safety ...">serdes::array</a> object's size exceeded the maximum size of the array when evaluated (causes the serdes process to abort) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1386add7959df5d7268423869485cd3eab0b3809be1740d3f1c8d5f4c225ed774"></a>INVALID_FIELD&#160;</td><td class="fielddoc">
<p>a fields validation check failed (causes the serdes process to abort) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1386add7959df5d7268423869485cd3eacce998e2340482b1544fb0e9ddd65d02"></a>NO_LOAD_TO_RVALUE&#160;</td><td class="fielddoc">
<p>tried to loading data from a serial buffer into a temperary rvalue (causes the serdes process to abort) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1386add7959df5d7268423869485cd3ea094d2eb6e3f6b6a7862b400026526a7e"></a>DELIMITER_NOT_FOUND&#160;</td><td class="fielddoc">
<p>the specified delimiter in a <a class="el" href="structserdes_1_1delimited__array.html" title="a container for dynamically sized arrays with their ending marked by a reserved delimiter value ...">delimited_array</a> object was not found before the end of the array (causes the serdes process to abort) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a1386add7959df5d7268423869485cd3ea2d9d52b93e3296d1a982d0ac57a1a9b6"></a>FORMATTER_NOT_SET&#160;</td><td class="fielddoc">
<p>a pure_virtual_formatter (a.k.a "serdes::formatter(nullptr)") was used but not overriden (causes the serdes process to abort) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aae83c837de13826a8e931d10eb863da6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr T serdes::bit_length </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does nothing but annotate a passed value as a bit length, used for writting clearer code. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>bit length value </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of the bit length value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr size_t: the same bit length value that was used as the input </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="01_simple_example_8cpp-example.html#a2">01_simple_example.cpp</a>, and <a class="el" href="02_bitcpy_usage_8cpp-example.html#a2">02_bitcpy_usage.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="abfcaa320138ca1dd74956eaaf2a3855b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_array , typename T_val , detail::requires_unsigned_type&lt; T_val &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t serdes::bitcpy </td>
          <td>(</td>
          <td class="paramtype">T_array *const&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_val&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bit_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bits</em> = <code>detail::default_bitsize&lt;T_val&gt;::value</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[[serialize, uint source]] copies the specified number of bits from a value into an array </p>
<p>[[serialize, signed type source]] copies the specified number of bits from a value into an array</p>
<p>[[serialize, integral value &lt;= 8 bytes source]] copies the specified number of bits from a value into an array</p>
<p>[[serialize, bool source]] copies the specified number of bits from a value into an array</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_array</td><td>destination serial array base type </td></tr>
    <tr><td class="paramname">T_val</td><td>source value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to the start of the destination serial array </td></tr>
    <tr><td class="paramname">source</td><td>source value reference </td></tr>
    <tr><td class="paramname">bit_offset</td><td>starting bit of the destination array to start copying from </td></tr>
    <tr><td class="paramname">bits</td><td>number of bits to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t: number of bits coppied </dd></dl>

</div>
</div>
<a class="anchor" id="aeb36906db6ba496a47d522c5ccbdb85e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_array , typename T_val , detail::requires_unsigned_type&lt; T_val &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t serdes::bitcpy </td>
          <td>(</td>
          <td class="paramtype">T_val &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_array *const&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bit_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bits</em> = <code>detail::default_bitsize&lt;T_val&gt;::value</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[[deserialize, uint destination]] copies the specified number of bits from an array into a value </p>
<p>[[deserialize, large non integral type dest]] copies the specified number of bits from an array into a large non integral type value</p>
<p>[[deserialize, signed destination]] copies the specified number of bits from an array into a signed value</p>
<p>[[deserialize, bool destination]] copies the specified number of bits from an array into a boolean value</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_array</td><td>serial array base type </td></tr>
    <tr><td class="paramname">T_val</td><td>destination value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>destination value reference </td></tr>
    <tr><td class="paramname">source</td><td>pointer to the start of the source serial array </td></tr>
    <tr><td class="paramname">bit_offset</td><td>starting bit of the source array to start copying from </td></tr>
    <tr><td class="paramname">bits</td><td>number of bits to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t: number of bits coppied</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_array</td><td>serial array base type </td></tr>
    <tr><td class="paramname">T_val</td><td>destination value type, a boolean for this case. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>destination boolean value reference </td></tr>
    <tr><td class="paramname">source</td><td>pointer to the start of the source serial array </td></tr>
    <tr><td class="paramname">bit_offset</td><td>starting bit of the source array to start copying from </td></tr>
    <tr><td class="paramname">bits</td><td>number of bits to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t: number of bits coppied </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="02_bitcpy_usage_8cpp-example.html#a0">02_bitcpy_usage.cpp</a>, <a class="el" href="11_using_atomics_with_bitcpy_8cpp-example.html#a0">11_using_atomics_with_bitcpy.cpp</a>, and <a class="el" href="12_compile_time_bitcpy_evaluation_8cpp-example.html#a0">12_compile_time_bitcpy_evaluation.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ac420621710d6586ff55c2f760e6b0bd0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_array , typename T_val , detail::requires_small_non_integral_type&lt; T_val &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t serdes::bitcpy </td>
          <td>(</td>
          <td class="paramtype">T_val &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_array *const&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bit_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bits</em> = <code>detail::default_bitsize&lt;T_val&gt;::value</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[[deserialize, integral value &lt;= 8 bytes destination]] copies the specified number of bits from an array into a integral value with &lt;= 8 bytes </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_array</td><td>serial array base type </td></tr>
    <tr><td class="paramname">T_val</td><td>destination value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>destination value reference </td></tr>
    <tr><td class="paramname">source</td><td>pointer to the start of the source serial array </td></tr>
    <tr><td class="paramname">bit_offset</td><td>starting bit of the source array to start copying from </td></tr>
    <tr><td class="paramname">bits</td><td>number of bits to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t: number of bits coppied </dd></dl>

</div>
</div>
<a class="anchor" id="a290f80d3a7efd5dda1ba082ca046585f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_array , typename T_val , detail::requires_unsigned_type&lt; T_val &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t serdes::bitcpy </td>
          <td>(</td>
          <td class="paramtype">T_array *const&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a>&lt; const T_val &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bit_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[[serialize, partial <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> source]] copies the specified number of bits from a value into an array (no default bits, since it can't necessarily be known at compile time) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_array</td><td>destination serial array base type </td></tr>
    <tr><td class="paramname">T_val</td><td>source value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to the start of the destination serial array </td></tr>
    <tr><td class="paramname">source</td><td>source value reference </td></tr>
    <tr><td class="paramname">bit_offset</td><td>starting bit of the destination array to start copying from </td></tr>
    <tr><td class="paramname">bits</td><td>number of bits to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t: number of bits coppied </dd></dl>

</div>
</div>
<a class="anchor" id="a70ab8ae5d7fb01f72921d88143ad838e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_array , typename T_val , detail::requires_unsigned_type&lt; T_val &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t serdes::bitcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a>&lt; T_val &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_array *const&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bit_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[[deserialize, partial <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> destination]] copies the specified number of bits from an array into a <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> array (no default bits, since it can't necessarily be known at compile time) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_array</td><td>serial array base type </td></tr>
    <tr><td class="paramname">T_val</td><td>destination value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>destination value sized_pointer&lt;T_val&gt; reference </td></tr>
    <tr><td class="paramname">source</td><td>pointer to the start of the source serial array </td></tr>
    <tr><td class="paramname">bit_offset</td><td>starting bit of the source array to start copying from </td></tr>
    <tr><td class="paramname">bits</td><td>number of bits to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t: number of bits coppied </dd></dl>

</div>
</div>
<a class="anchor" id="ac3822dc8bf6c6b646b4f919b985be98f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_array , typename T_val , detail::requires_unsigned_type&lt; T_val &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t serdes::bitcpy </td>
          <td>(</td>
          <td class="paramtype">T_array *const&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a>&lt; const T_val &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bit_offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[[serialize, entire <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> source]] copies the entire <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> object from a value into an array </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_array</td><td>destination serial array base type </td></tr>
    <tr><td class="paramname">T_val</td><td>source value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to the start of the destination serial array </td></tr>
    <tr><td class="paramname">source</td><td>source value reference </td></tr>
    <tr><td class="paramname">bit_offset</td><td>starting bit of the destination array to start copying from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t: number of bits coppied </dd></dl>

</div>
</div>
<a class="anchor" id="abed7367b5b4757ec2d64cf63b38e8a92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_array , typename T_val , detail::requires_large_non_integral_type&lt; T_val &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitcpy__common_8h.html#acd60295e3ef245aee68c06dcdb623899">CONSTEXPR_ABOVE_CPP11_AND_NON_LITERAL_STORAGE</a> size_t serdes::bitcpy </td>
          <td>(</td>
          <td class="paramtype">T_array *const&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_val &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bit_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bits</em> = <code>detail::default_bitsize&lt;T_val&gt;::value</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[[serialize, large non integral type source]] copies the specified number of bits from a value into an array </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_array</td><td>destination serial array base type </td></tr>
    <tr><td class="paramname">T_val</td><td>source value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to the start of the destination serial array </td></tr>
    <tr><td class="paramname">source</td><td>source value reference </td></tr>
    <tr><td class="paramname">bit_offset</td><td>starting bit of the destination array to start copying from </td></tr>
    <tr><td class="paramname">bits</td><td>number of bits to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t: number of bits coppied </dd></dl>

</div>
</div>
<a class="anchor" id="a262780a7330bf9baf1e44ba061061210"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_array , typename T_val , detail::requires_unsigned_type&lt; T_val &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t serdes::bitcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a>&lt; T_val &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_array *const&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bit_offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[[deserialize, entire <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> destination]] copies the specified number of bits from an array into a <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> array using a bit length equal to the entire bit capacity of the <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_array</td><td>serial array base type </td></tr>
    <tr><td class="paramname">T_val</td><td>destination value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>destination value sized_pointer&lt;T_val&gt; reference </td></tr>
    <tr><td class="paramname">source</td><td>pointer to the start of the source serial array </td></tr>
    <tr><td class="paramname">bit_offset</td><td>starting bit of the source array to start copying from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t: number of bits coppied </dd></dl>

</div>
</div>
<a class="anchor" id="aa5c4caa1535f33f05f3a6d94ba3efcc4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_array  = void, typename T_val  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t serdes::bitcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a>&lt; T_array &gt;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_val &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bit_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bits</em> = <code>detail::default_bitsize&lt;T_val&gt;::value</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[[serialize, size safe]] copies the specified number of bits from a value into an sized array </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_array</td><td>destination serial array base type </td></tr>
    <tr><td class="paramname">T_val</td><td>source value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to the start of the destination serial array </td></tr>
    <tr><td class="paramname">source</td><td>source value reference </td></tr>
    <tr><td class="paramname">bit_offset</td><td>starting bit of the destination array to start copying from </td></tr>
    <tr><td class="paramname">bits</td><td>number of bits to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t: number of bits coppied </dd></dl>

</div>
</div>
<a class="anchor" id="a563cbbec75f2b1acbf054dddfbccfae9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_array , typename T_val &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t serdes::bitcpy </td>
          <td>(</td>
          <td class="paramtype">T_array *const&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::atomic&lt; T_val &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bit_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bits</em> = <code>detail::default_bitsize&lt;T_val&gt;::value</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[[serialize, atomic source]] copies the specified number of bits from an atomic value into an sized array </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_array</td><td>destination serial array base type </td></tr>
    <tr><td class="paramname">T_val</td><td>source value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to the start of the destination serial array </td></tr>
    <tr><td class="paramname">source</td><td>source value reference </td></tr>
    <tr><td class="paramname">bit_offset</td><td>starting bit of the destination array to start copying from </td></tr>
    <tr><td class="paramname">bits</td><td>number of bits to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t: number of bits coppied </dd></dl>

</div>
</div>
<a class="anchor" id="a1e6f27bcacd3783064c59334545bccbc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_array  = void, typename T_val  = void, detail::requires_not_a_pointer_type&lt; T_val &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t serdes::bitcpy </td>
          <td>(</td>
          <td class="paramtype">T_val &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a>&lt; T_array &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bit_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bits</em> = <code>detail::default_bitsize&lt;T_val&gt;::value</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[[deserialize, size safe]] copies the specified number of bits from an <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> into a value. used to prevent reading beyond the boundary of the source array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_array</td><td>serial array base type </td></tr>
    <tr><td class="paramname">T_val</td><td>destination value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>destination value reference </td></tr>
    <tr><td class="paramname">source</td><td>pointer to the start of the source serial array </td></tr>
    <tr><td class="paramname">bit_offset</td><td>starting bit of the source array to start copying from </td></tr>
    <tr><td class="paramname">bits</td><td>number of bits to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t: number of bits coppied </dd></dl>

</div>
</div>
<a class="anchor" id="a812ea9df5d30f7477a5fa7f2590cb855"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_val &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t serdes::bitcpy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_val &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bit_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bits</em> = <code>detail::default_bitsize&lt;T_val&gt;::value</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[[serialize, size safe, type punned (void) dest array]] copies the specified number of bits from a value into an sized array </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_array</td><td>destination serial array base type </td></tr>
    <tr><td class="paramname">T_val</td><td>source value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>pointer to the start of the destination serial array </td></tr>
    <tr><td class="paramname">source</td><td>source value reference </td></tr>
    <tr><td class="paramname">bit_offset</td><td>starting bit of the destination array to start copying from </td></tr>
    <tr><td class="paramname">bits</td><td>number of bits to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t: number of bits coppied </dd></dl>

</div>
</div>
<a class="anchor" id="aae4d398974f1f43688103da879266b5d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_array  = void, typename T_val  = void, detail::requires_pointer_type&lt; T_val &gt; *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t serdes::bitcpy </td>
          <td>(</td>
          <td class="paramtype">T_val &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a>&lt; T_array &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bit_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bits</em> = <code>detail::default_bitsize&lt;T_val&gt;::value</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[[deserialize, size safe, pointer dest]] copies the specified number of bits from an <a class="el" href="structserdes_1_1sized__pointer.html" title="Holds a pointer to an array (with its type information) with a constant size. ">sized_pointer</a> into a value. used to prevent reading beyond the boundary of the source array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_array</td><td>serial array base type </td></tr>
    <tr><td class="paramname">T_val</td><td>destination value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>destination value reference </td></tr>
    <tr><td class="paramname">source</td><td>pointer to the start of the source serial array </td></tr>
    <tr><td class="paramname">bit_offset</td><td>starting bit of the source array to start copying from </td></tr>
    <tr><td class="paramname">bits</td><td>number of bits to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t: number of bits coppied </dd></dl>

</div>
</div>
<a class="anchor" id="a0f811a7c84f33ffe68bab7f660e036bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_array , typename T_val &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t serdes::bitcpy </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; T_val &gt; &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_array *const&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bit_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bits</em> = <code>detail::default_bitsize&lt;T_val&gt;::value</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[[deserialize, atomic dest]] copies the specified number of bits from an array into an atomic value </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_array</td><td>serial array base type </td></tr>
    <tr><td class="paramname">T_val</td><td>destination value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>destination value reference </td></tr>
    <tr><td class="paramname">source</td><td>pointer to the start of the source serial array </td></tr>
    <tr><td class="paramname">bit_offset</td><td>starting bit of the source array to start copying from </td></tr>
    <tr><td class="paramname">bits</td><td>number of bits to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t: number of bits coppied </dd></dl>

</div>
</div>
<a class="anchor" id="a59a3fc6527a4e0d32080cd8fc33c9492"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_val  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitcpy__common_8h.html#a9f5b30715812520382f5d9c62d9003cc">CONSTEXPR_ABOVE_CPP11</a> size_t serdes::bitcpy </td>
          <td>(</td>
          <td class="paramtype">T_val &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structserdes_1_1sized__pointer.html">sized_pointer</a>&lt; void &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bit_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bits</em> = <code>detail::default_bitsize&lt;T_val&gt;::value</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>[[deserialize, size safe, type punned (void) source array]] copies the specified number of bits from an array with a runtime determined base type into a value </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_array</td><td>serial array base type </td></tr>
    <tr><td class="paramname">T_val</td><td>destination value type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>destination value reference </td></tr>
    <tr><td class="paramname">source</td><td>pointer to the start of the source serial array </td></tr>
    <tr><td class="paramname">bit_offset</td><td>starting bit of the source array to start copying from </td></tr>
    <tr><td class="paramname">bits</td><td>number of bits to copy from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t: number of bits coppied </dd></dl>

</div>
</div>
<a class="anchor" id="a8c5a3aa91ba45e310943c6704282b9f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool use_brackets = true, typename T  = void, size_t N = 0u&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void serdes::printbin </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>data</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>add_newline</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prints an array in binary format </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">use_brackets</td><td>if true, curly brackets will surround the printed statement </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to print </td></tr>
    <tr><td class="paramname">add_newline</td><td>if true, a newline will be added to the end </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="06_variable_length_formats_8cpp-example.html#a6">06_variable_length_formats.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a966991bf9e4d6f119b26dd034723033c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt;!std::is_array&lt; T &gt;::value &amp;&amp;!std::is_same&lt; T, bool &gt;::value, T &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void serdes::printbin </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>add_newline</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prints a non-array non-bool value in binary format </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to print </td></tr>
    <tr><td class="paramname">add_newline</td><td>if true, a newline will be added to the end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9a594b0b4cc5b5a2465fff972f97f064"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serdes::printbin </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>add_newline</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>prints a bool value in binary format </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to print </td></tr>
    <tr><td class="paramname">add_newline</td><td>if true, a newline will be added to the end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a51272e70dce3f7117d7d4fcac70ecc4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serdes::printhex </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>add_newline</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>prints uint8_t value in hex format </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to print </td></tr>
    <tr><td class="paramname">add_newline</td><td>if true, a newline will be added to the end </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="02_bitcpy_usage_8cpp-example.html#a1">02_bitcpy_usage.cpp</a>, <a class="el" href="03_serial_usage_8cpp-example.html#a1">03_serial_usage.cpp</a>, <a class="el" href="06_variable_length_formats_8cpp-example.html#a5">06_variable_length_formats.cpp</a>, and <a class="el" href="08_error_handling_8cpp-example.html#a5">08_error_handling.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="ad99828104ac858f4a260c2f90bc4ad20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serdes::printhex </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>add_newline</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>prints uint16_t value in hex format </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to print </td></tr>
    <tr><td class="paramname">add_newline</td><td>if true, a newline will be added to the end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8c848bf29b2209e63ee38dad08ad5523"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serdes::printhex </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>add_newline</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>prints uint32_t value in hex format </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to print </td></tr>
    <tr><td class="paramname">add_newline</td><td>if true, a newline will be added to the end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adab1afab999d6c5890f76ea47095b514"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serdes::printhex </td>
          <td>(</td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>add_newline</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>prints uint64_t value in hex format </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to print </td></tr>
    <tr><td class="paramname">add_newline</td><td>if true, a newline will be added to the end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ace267eee6dd224c9a2c1fde6a0f66e32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void serdes::printhex </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>add_newline</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>prints bool value in hex format </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to print </td></tr>
    <tr><td class="paramname">add_newline</td><td>if true, a newline will be added to the end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af56375888a9a3ba6d6488a73d6866b75"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T  = void, typename std::enable_if&lt; std::is_signed&lt; T &gt;::valueBITCPY_INT128_CONDITIONAL_DEFINE(||std::is_same&lt; T, __int128_t &gt;::value), T &gt;::type *  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void serdes::printhex </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>add_newline</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prints signed value in hex format </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to print </td></tr>
    <tr><td class="paramname">add_newline</td><td>if true, a newline will be added to the end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9208ad46c43f085998183fb3afde4c00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool use_brackets = true, typename T  = void, size_t N = 0u&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void serdes::printhex </td>
          <td>(</td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>data</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>add_newline</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prints an array in hex format </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">use_brackets</td><td>if true, curly brackets will surround the printed statement </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>value to print </td></tr>
    <tr><td class="paramname">add_newline</td><td>if true, a newline will be added to the end </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb584d0e8c2555c37f71f48e362cc268"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* serdes::status2str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceserdes.html#a1386add7959df5d7268423869485cd3e">status_e</a>&#160;</td>
          <td class="paramname"><em>err_status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>converts an error status enum to a c style string </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">err_status</td><td>error status enumeration </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const char*: converted string </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="04_object_oriented_serial_8cpp-example.html#a3">04_object_oriented_serial.cpp</a>, <a class="el" href="05_nested_object_oriented_serial_8cpp-example.html#a8">05_nested_object_oriented_serial.cpp</a>, <a class="el" href="07_delimited_arrays_8cpp-example.html#a4">07_delimited_arrays.cpp</a>, <a class="el" href="08_error_handling_8cpp-example.html#a4">08_error_handling.cpp</a>, <a class="el" href="09_runtime_edittable_formats_8cpp-example.html#a6">09_runtime_edittable_formats.cpp</a>, <a class="el" href="10_virtual_fields_8cpp-example.html#a7">10_virtual_fields.cpp</a>, and <a class="el" href="13_arrays_of_packets_8cpp-example.html#a4">13_arrays_of_packets.cpp</a>.</dd>
</dl>
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceserdes.html">serdes</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
